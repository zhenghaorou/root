什么是集群
一组通过高速网络互联的计算组，并以单一系统的模式加以管理
将很多服务器集中起来一起，提供用一种服务，在客户端看来就像是只有一个服务器
可以在付出比较低成本的情况下获得在性能，可靠性，灵活性方面的相对较高的收益
任务调度是集群系统中的核心技术
提高性能
如计算密集型应用，如:天气预报，核试验模拟
降低成本
相对百万美元级的超级计算机，价格便宜
提高可扩展性
只要增加集群节点即可
增强可靠性
多个节点完全相同功能，避免单点失败

集群分类
高性能计算集群HPC
负载均衡LB集群(平均分摊)
高可用HA集群(避免单点故障)，当一个系统发生故障时，可以快速迁移

(LVS原理跟ngiinx完全不同)
用路由器的原理理解LVS

lVS集群组成
前段：负载均衡层
－由一台或多台　负载调度器构成
中间：服务器群组成
有实际的服务器组成
底段：数据共享存成层：ＮＦＳ
VIP:虚拟ＩＰ地址
公布给用户访问的虚拟ＩＰ地址
ＲＩＰ：真是ｉｐ地址
集群节点上使用的ＩＰ地址
ＤＩＰ：调度器链接节点服务器的ＩＰ地址
　
VS/NAT 
通过网络地址转换实现的虚拟服务器
大并发访问时，调度器的性能成为瓶
VS/DR
直接使用路由技术实现虚拟服务器
节点服务器需要配置VIP,注意MAC地址广播
负载均衡调度算法
lVS 目前实现的10种调度算法
常见的有4种
轮询     rr
加权轮询   wrr
最少链接    lc
加权最少链接   wlc

源地址散列　SH
根据请求的目标ｉｐ地址，作为散列建从静态分配的散列找出对应的服务器（跟nginx的ip_hash道理一样）

client-----------lvs(NAT)---------------web1(网关)
s:4.10  ->      4.10    4.10    ->      4.10
d:4.5v  ->      4.5v    2.100r  ->      2.100r
--------------------------------------------------
s:4.5v  <-      4.5v    2.100r  <-      2.100r
d:4.10  <-      4.10    4.10    <-      4.10



###############################################################################################################
步骤一：使用命令增、删、改LVS集群规则
会使用ipvsadm实现规则的增、删、改
创建LVS虚拟集群服务器（算法为加权轮询：wrr）

yum -y install ipvsadm   //装可以与内核LVS传递的规则的命令包

[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr    //-A添加虚拟服务器　-t 协议为tcp -s加规则
[root@proxy ~]# ipvsadm -Ln      //查看LVS规则表


为集群添加若干real server

[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 //-a添加真实服务器 -r 真实服务器的ip -w 设置权重
[root@proxy ~]# ipvsadm -Ln　

如果TCP  192.168.4.5:80 rr  //rr 为轮询　　设置权重值没有用　要修改为wrr

root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3    //加-m 为NAT模式　-i 隧道模式 什么都不加是加DR
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4

-> 192.168.2.100:80             Route   1      0          0         
  -> 192.168.2.200:80             Route   2      0          0         
  -> 192.168.2.201:80             Masq    2      0          0         
  -> 192.168.2.202:80             Masq    2      0          0 


修改集群服务器设置(修改调度器算法，将轮询修改为权重)
[root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s wrr
[root@proxy ~]# ipvsadm -Ln

修改read server（使用-g选项，将模式改为DR模式）
[root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g

创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m

永久保存所有规则
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

8）清空所有规则
[root@proxy ~]# ipvsadm -C

###############################################################################################################

部署LVS-NAT集群

集群对外公网IP地址为192.168.4.5
调度器内网IP地址为192.168.2.5
真实Web服务器地址分别为192.168.2.100、192.168.2.200
使用加权轮询调度算法，真实服务器权重分别为1和2


3 步骤

实现此案例需要按照如下步骤进行。
步骤一：配置基础环境
1）设置Web服务器（以web1为例）

route -n 查看网关 

步骤二：部署LVS-NAT模式调度器
1)确认调度器的路由转发功能(如果已经开启，可以忽略)
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# cat /proc/sys/net/ipv4/ip_forward
1
[root@proxy ~]# echo "net.ipv4.ip_forward = 1" >> /etc/sysctl.conf
#修改配置文件，设置永久规则

创建集群服务器
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
3）添加真实服务器
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -w 1 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -w 1 -m
4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm
步骤三：客户端测试
客户端使用curl命令反复连接http://192.168.4.5，查看访问的页面是否会轮询到不同的后端真实服务器。

################################################################################################################

部署LVS-DR集群
客户端IP地址为192.168.4.10
LVS调度器VIP地址为192.168.4.15
LVS调度器DIP地址设置为192.168.4.5
真实Web服务器地址分别为192.168.4.100、192.168.4.200
使用加权轮询调度算法，web1的权重为1，web2的权重为2

CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；   //公网ip
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。

骤一：配置实验网络环境
1）设置Proxy代理服务器的VIP和DIP
注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口(次接口)！！！    //eth0为主接口　eht0:0为虚拟接口｜次接口

[root@proxy ~]# cd /etc/sysconfig/network-scripts/
cp ifcfg-eth0 ifcfg-eth0:0

[root@proxy ~]# vim ifcfg-eth0:0                 //把没用的删掉
TYPE=Ethernet
BOOTPROTO=none                 //不要自动获取．如果自动获取的话就是dhcp
DEFROUTE=yes
NAME=eth0:0                //网卡名
DEVICE=eth0:0
ONBOOT=yes                //开机自启
IPADDR=192.168.4.15        //网卡ip
PREFIX=24                 

[root@proxy ~]# systemctl restart network    //重启服务 //如果网卡起不来的话就 systemctl stop NetworkManager

##############################################################################################################

设置Web1服务器网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0


接下来给web1配置VIP地址。                                                                         (有网线的网卡不能伪装)                    
注意：这里的子网掩码必须是32（也就是全255）网络地址与IP地址一样，广播地址与IP地址也一样.lo回环网卡(隐藏伪装lo网卡)，不能链接有线网卡
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo ifcfg-lo:0
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15       //ip地址
NETMASK=255.255.255.255    //子网掩码
NETWORK=192.168.4.15   
BROADCAST=192.168.4.15　
ONBOOT=yes        //开机自启
NAME=lo:0         //名字

防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1　　　　　　　　　　　//默认值为0广播全回答,改为1 有的才说，（伪装是假的所以不说）
net.ipv4.conf.lo.arp_ignore = 1                             //所有不包括lo,所以lo要单独设
net.ipv4.conf.lo.arp_announce = 2            //宣告，0为全说,1为尽量不说，2为不说
net.ipv4.conf.all.arp_announce = 2

#arp_ignore = 1      当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应 
#arp_announce = 2     本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web1 ~]# sysctl -p　　　//刷新一下

重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
常见错误：如果重启网络后未正确配置lo:0，有可能是NetworkManager和network服务有冲突，关闭NetworkManager后重启network即可。（非必须的操作）
[root@web1 ~]# systemctl stop NetworkManager
[root@web1 ~]# systemctl restart network


web2也要做一样的操作，参数改变
[root@web2 ~]# rm -rf /etc/sysctl.conf

直接远程传输过去
scp /etc/sysconfig/network-scripts/ifcfg-lo:0 root@192.168.2.200:/etc/sysconfig/network-scripts/
scp /etc/sysctl.conf root@192.168.2.200:/etc/

可以吧这服务器设置重复的操作写成脚本

################################################################################################################
proxy调度器安装软件并部署LVS-DR模式调度器

2）清理之前实验的规则，创建新的集群服务器规则
[root@proxy ~]# ipvsadm -C                                #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr
3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1
4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   2      0          0

#######################################################################################################
 客户端测试
客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
扩展知识：默认LVS不带健康检查功能，需要自己手动编写动态检测脚本，实现该功能：(参考脚本如下，仅供参考)

[root@proxy ~]# vim check.sh               测试不带健康检查   (健康检查就是有服务器坏了会自动一定时间内不链接坏的服务器）
#!/bin/bash
VIP=192.168.4.15:80
RIP1=192.168.4.100
RIP2=192.168.4.200
while :
do
   for IP in $RIP1 $RIP2
   do
           curl -s http://$IP &>/dev/vnull
if [ $? -eq 0 ];then
            ipvsadm -Ln |grep -q $IP || ipvsadm -a -t $VIP -r $IP
        else
             ipvsadm -Ln |grep -q $IP && ipvsadm -d -t $VIP -r $IP
        fi
   done
sleep 1
done






















